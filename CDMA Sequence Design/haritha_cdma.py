# -*- coding: utf-8 -*-
"""Haritha_CDMA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fFEaR53DofD4yG-bY1nvLJspDWPhL1OA

Applications of Majorization Theory
> CDMA Sequence Design illustration


---

Done by Haritha.R ( AI20BTECH11010 )
"""

import numpy as np
import math

# Problem data.
K = 3
N = 4    # N >=K
p = np.random.randint(10,size=K)
sigma= np.random.random(1)[0]  


print("K = ",K,",N = ",N,"sigma=",sigma,"\n")
P= np.zeros((K,K))
for i in range(K):
      P[i,i]=p[i]
      print("p",i+1," = ",round(p[i],4))


S=np.array([[1, (1/math.sqrt(2)) , 1/2],
   [0, (1/math.sqrt(2)) , 1/2],
   [0, 0 , 1/2],
   [0, 0 , 1/2]])

print("\nColumn wise norms of S:")
norm_S= np.linalg.norm(S, axis = 0)
for i in range(K):
    print(" ||s",i+1,"|| =",round(norm_S[i] ))

A=np.dot(np.dot(S,P) ,S.T)
print("\n SP(S^T) =\n ",A)

Eigen_values_lambdas,Eigen_vectors=np.linalg.eig(A)

print("\nEigen Values of SP(S^T) =")
for i in range(N):
     print("lamda",i+1,"=",round(Eigen_values_lambdas[i],4))


lamda=Eigen_values_lambdas[:K]

p.sort()
p_cum_sum =np.cumsum(p)

lamda.sort()
lambda_cum_sum=np.cumsum(lamda)
 
print("\n cumulative sum of p in ascending order=",p_cum_sum,"\ncumulative sum of lambda in ascending order=",lambda_cum_sum)
if((lambda_cum_sum <= p_cum_sum).all):
  print("clearly lambda majorises p ")

twsc = sum(np.square(Eigen_values_lambdas))

mse=K
c_sum=0
for i in range(N):
  l=Eigen_values_lambdas[i]
  c_sum = c_sum + (( math.log(1+ l/(sigma*sigma)) )/2)
  mse= mse - (l /(l + (sigma*sigma)) )

print("mimimum TWSC=",twsc,"\n minimum MMSE=",mse,"\n maximum sum capacity=",c_sum)